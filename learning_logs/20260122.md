# 입실 체크 해주세요 !! 🎈

ch09_applied
# 용도에 따른 태그 사용하기
`<!DOCTYPE html>` : html5 형식으로 작성되었다는 것을 명시
얘가 빠지면 옛날 브라우저 형태로 문서를 읽게되는데 그러면 HTML / CSS / JS가 호환되지 않아서 생각하지 못한 문제가 발생할 수 있습니다.

`<head>` : 메타데이터, 우리가 웹사이트에서 눈으로 볼 수는 없지만 컴퓨터가 읽어 낼 문서의 정보와 사양이 담겨있습니다.
  - `<title>` : 브라우저 상단 탭에 나타나는 사이트 제목에 해당함 -> 북마크 / 즐겨찾기를 했을 때 저장되는 이름입니다. / 구글과 같은 검색엔진에서 나타나는 검색 결과에 표시되는 제목이기도 함.

  - `<meta>` :
    1. charset : 해당 페이지에 사용된 문자들을 어떤 방식으로 읽을지를 명시.
      lang="ko" 검색 엔진이나 스크린 리더에 이 사이트가 어떤 언어인지를 알려주는 역할에 해당하고, "UTF-8"은 문자 인코딩 방식을 의미하기 때문에 독립적으로 생각해야 합니다.

    2. viewport : 화면에 보여지는 영역을 의미했었습니다. 모바일 기준으로 봤을 때는 사람 눈에 보이는 시각적인 뷰포트(visual viewport)와 브라우저가 웹페이지를 표시하는 영역에 해당하는 레이아웃 뷰포트(layout viewport)가 대체로 동일하기는 합니다. 근데 input 태그 등을 클릭하게 되면 키보드가 올라오게 되는데, 그러면 레이아웃 뷰포트 =/= 시각적 뷰포트가 어긋나는 경우가 생깁니다. 이상과 같은 상황이 생기더라도 웹사이트 내용이 깨지지 않도록 유지시켜주는 부분이라고 할 수 있습니다.

    3. Open Graph 정보
    - 메타(전 페이스북)에서 만든 프로토콜로 웹페이지의 주소를 복사해서 페이스북/카카오톡 등의 SNS 등의 계정으로 공유할 때 보여지는 웹사이트 제목과 썸네일 등의 기본 정보를 태그 형태로 정의하는 방식.

```html
<head>
  <meta property="og:title" content="Korea IT Academy 12월 국비 과정">
  <meta property="og:description" content="심화 HTML / CSS 및 기초 JavaScript 과정">
  <meta property="og:image" content="https://showcases.yalco.kr/html-css-scoop/03-01.png">
</head>
```
와 같이 작성하게 되면 공유했을 때 썸네일로 이미지, 그리고 조금 두꺼운 폰트로 제목 / 그리고 생략 ...을 포함한 내용이 SNS에 포함되게 됩니다.

  - favicon : 상단 탭 제목 옆에 원하는 이미지 삽입 가능
```html
<link rel="shortcut icon" href="./상대경로.png" type="image/x-icon">
```

# 시맨틱 태그(Semantic Tags)
- div / span 태그만 이용해도 웹페이지를 만드는 것이 가능하지만, 어떤 용도로 사용되는지 구분하는 것이 어렵습니다(그래서 옛날에는 div 태그에 class로 기능이나 용도를 하나하나 다 집어넣기도 했습니다). 이 부분을 해결하기 위한 개념이 시맨틱 태그입니다.

## 시맨틱 태그의 장점
- 의미있는 태그라는 의미로, HTML5에서 적극적으로 활용하여 웹사이트를 구성합니다.
- 근데 얘 자체는 `<div>`이랑 동일한데, 역할 별로 이름 다르게 붙여진 div라고 보시면 됩니다.
1. 웹 접근성 개선 : 스크린 리더를 활용하여 웹페이지를 볼 때 필요한 정보를 빠르게 읽어줍니다.
2. SEO 상의 장점 : 검색엔진을 통하게 되면 검색창에서 내부 페이지 정보를 간략하게 보여주는데, 이때 검색엔진이 노출시켜 주는 부분을 의도한대로 나오게 하기가 쉽습니다.
3. 유지보수와 가독성에 유리 : 계속해서 변경을 해줘야 하는데, 전부 div로 되어있으면 쉽게 찾을 수 있는가의 문제가 있습니다.
## 시맨틱 태그의 종류
1. `<header>` : 페이지나 구획의 최상단에서 제목 역할을 하는 요소를 두는 데 사용. 주로 웹 페이지의 제목 / 로고 / 검색 창 등을 포함합니다. 전체 웹페이지를 대상으로 하는 것이 아니라, 사이트 내 어떤 구획의 요소라도 필요하다면 사용 가능합니다.

2. `<nav>` : 링크로 이동하는 요소를 포함. 페이지의 메뉴나 색인(index) 등 하이퍼링크가 있는 부분에 사용됩니다. 페이지 내에 id로 지정된 요소가 있다면 그 요소로 바로 이동할 때 사용하기도 합니다(특정 id 클릭해서 넘어가는 부분을 HTML 수업 때 했습니다).

3. `<footer>` : 헤더와 반대로 페이지나 구획의 최하단에 보여지는 요소를 두는 데 사용. 주로 회사의 연락처 정보나 저작권 문구 등을 작성하는 공간에 해당합니다. 헤더와 마찬가지로 사이트 내 어떤 구획의 요소라도 필요하다면 사용 가능.

4. `<main>` : 페이지의 가장 중요한 부분으로 주요 내용이 들어가는 메인 영역에 사용. 페이지마다 '반드시 한 개만' 존재해야 합니다. 해당 페이지의 유일한 주 컨텐츠 공간.

5. `<aside>` : 메인과 어느 정도 간접적으로 연관된 컨텐츠를 포함하는 데 사용 되는데, 주로 사이드 바 역할을 합니다.

6. `<section>` : 페이지의 컨텐츠를 주제나 성격에 따라 일정 단위의 구획으로 나누는 데 사용됩니다. 이보다 더 작은 단위로 나누기 시작한다면 그때는 `<div>`를 사용합니다. 사이트 내 여러 군데에 사용 가능하며 각 섹션마다 id 지정을 통해 링크로 이동할 수 있도록 합니다.

7. `<article>` : 페이지 내에서 여러 번 재사용되거나 페이지로부터 독립적인, 즉 다른 페이지에서도 사용될 수 있는 컨텐츠에 주로 사용됩니다. 주로 페이지 내의 카드 요소, 기사나 블로그 포스트, 댓글 등이 해당됩니다.

8. `<figure>` : 주로 이미지를 넣는 `<img>`태그와 그 이미지를 설명하는 캡션을 넣는 `<figcaption>` 태그를 묶어놓을 때 사용합니다.

# 기타 미디어 삽입
## SVG 이미지
SVG란 ? Scalable Vector Graphics는 일반적인 png나 jpg 와 다른 이미지 파일입니다. 픽셀 이미지는 확대할 수록 픽셀 단위가 커지면서 해상도가 떨어지는데, svg는 확대해도 이미지가 깨지지 않는 특징이 있습니다. 

1. 이미지 파일 경로를 삽입하는 방법을 쓸 수 있습니다.
<img src="https://showcases.yalco.kr/html-css-scoop/03-05/yalco-y.svg" alt="얄코 개발자님 항상 신세지고 있습니다">

2. svg 소스를 불러오는 방법
웹 상에 올려져있는 svg 이미지를 불러올 경우에 _이미지를 다른 이름으로 저장_ 을 선택해서 저장합니다. 그리고 탐색기창으로 불러올 때 소스 코드 형식으로 불러오게 될 경우에

`<svg> / <style> 및 좌표 공식을 가지는 <path>` 태그로 이루어져있습니다.
이를 `<figure>` 태그에 넣어서 사용하는데, 크기 조절을 하는 등 추가적인 편집이 필요합니다.

## 오디오와 동영상
01_audio_video.html

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body bgcolor="5f5f5f">
  <h1>01_audio_video.html</h1>
  <figure>
    <figcaption>
      얄코님 영상 오디오
    </figcaption>
    <audio src="https://showcases.yalco.kr/html-css-scoop/03-05/audio.mp3" controls></audio>
  </figure>
  <br>
  <figure>
    <figcaption>얄코님 영상 비디오</figcaption>
    <video src="https://showcases.yalco.kr/html-css-scoop/03-05/video.mp4" controls></video>
  </figure>
</body>
</html>
```
`<audio>` 태그는 이미지 태그처럼 src 속성에 오디오 파일의 경로를 넣습니다. controls라고 하는 속성이 있는데, 제어 인터페이스에 해당하는 것으로 '재생, 멈춤, 진행 등을 나타내는 컨트롤러를 표시합니다' controls가 없으면 페이지에 컨트롤러 자체가 뜨지 않아서 미디어를 재생할 수 없습니다.

autoplay 속성은 자동재생
loop 반복재생을 위한 속성에 해당합니다. 근데 최근에는 브라우저마다 자동 재생 기능을 막아두기 때문에 autoplay를 직접 쓰는 일은 잘 없을겁니다.

02_audio_video_src.html

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body bgcolor="5f5f5f">
  <h1>02_audio_video_src.html</h1>
  <figure>
    <figcaption>얄코님 영상 오디오</figcaption>
    <audio controls>
      <source src="https://showcases.yalco.kr/html-css-scoop/03-05/audio.mp3" type="audio/mpeg">
      <source src="https://showcases.yalco.kr/html-css-scoop/03-05/audio.wav" type="audio/wav">
      <p>이 브라우저에서 오디오 태그가 지원되지 않습니다.</p>
    </audio>
  </figure>
  <br>
  <figure>
    <figcaption>얄코님 영상 비디오</figcaption>
    <video controls>
      <source src="https://showcases.yalco.kr/html-css-scoop/03-05/video.mov" type="video/quicktime">
      <source src="https://showcases.yalco.kr/html-css-scoop/03-05/video.mp4" type="video/mp4">
      <source src="https://showcases.yalco.kr/html-css-scoop/03-05/video.webm" type="video/webm">
      <p>이 브라우저에서 비디오 태그가 지원되지 않습니다.</p>
    </video>
  </figure>
</body>
</html>
```

src 속성을 통해서 집어넣는 방법입니다. 그런데 일부러 여러 예시를 저장했습니다. 윈도우 버전의 edge나 Mac에서는 mov를 또 지원 안합니다. 그래서 브라우저 별로 다르게 지원을 하기 때문에 동일한 영상이라도 확장자마다 집어넣어야 할 때도 있습니다. 이상을 이유로 동일한 source를 준비해서 올립니다.

브라우저에 따라서 어떤 태그나 파일 형식이 사용가능한지를 ai를 통해 미리 체크하는 것도 중요해졌습니다.

그리고 브라우저 상에서 '이 브라우저에서 오디오 태그가 지원되지 않습니다'문구가 저희 눈에는 보이지 않는다는 점도 눈여겨 봐야 합니다.

이는 audio 태그나 video 태그가 아예 없는 구 버전 브라우저에서 _대신 보여주는_ 문구에 해당합니다. img 태그의 alt같은거라고 볼 수 있습니다. 

## 가독성을 위한 이름 짓기
03_naming.html / css

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <link rel="stylesheet" href="./03_naming.css">
</head>
<body>
  <article>
    <aside>
      <figure></figure>
    </aside>
    <div>
      <header></header>
      <ul>
        <li class="speical"></li>
        <li></li>
        <li></li>
      </ul>
    </div>
  </article>
</body>
</html>
```

```css
article {/*...*/}
article aside {/*...*/}
article aside figure {/*...*/}
article div header {/*...*/}
article ul li {/*...*/}
article div li.speical {/*...*/}
```

이상과 같이 작성했을 경우에 혹시 반복되는 요소의 css가 깨질까봐 부모 요소를 계속 명시해줘야하는 문제가 생깁니다. 근데 추후에 article 하나 더 늘어나면 백퍼센트 문제 생기겠네요.

그러다보니 태그 이름만 가지고는 해당 요소가 사이트의 어떤 부분을 명시하는지 알기가 어려운 경우가 많습니다.

그래서 생겨난 방식으로,

## 클래스 위주로 이름짓기
시맨틱 태그만으로 이름을 짓는 방식에 한계가 있다면 _각 요소 마다 클래스명을 지정하는 방식_ 을 채택할 수 있습니다. 그리고 그 클래스명은 무슨 역할을 하는지 명확하게 적어주는 것이 그 목표입니다.

04_naming_modified.html / css

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <link rel="stylesheet" href="./03_naming.css">
</head>
<body>
  <article class="card">
    <aside class="thumb">
      <figure class="image"></figure>
    </aside>
    <div class="body">
      <header class="title"></header>
      <ul class="list">
        <li class="list-item-speical"></li>
        <li class="list-item"></li>
        <li class="list-item"></li>
      </ul>
    </div>
  </article>
</body>
</html>
```

```css
/* 
태그명으로 css 지정 시 얘가 정확하게 어디에 위치하는지 모른다.
article {}
article aside {}
article aside figure {}
article div header {}
article ul li {}
article div li.speical {}  */

.card {}
.card .thumb {}
.card .thumb .image {}
.card .body .title {}
.card .body .list {}
.card .body .list .list-item {}
.card .body .list .list-item.special {}
```
태그의 각 요소들이 무슨 역할을 하는지는 영어만 읽으면 이해가 되기는하는데, 그 영어를 읽기 위해서 엄청 태그 요소들이 길어졌고, CSS 선택자는 더 길어지는 문제가 생겼습니다. 결국 바깥쪽 요소부터 하나씩 들어간다는 점은 똑같습니다.

그래서 클래스만 사용해서 작성하는 방법보다 더 명확하게 사이트 내의 요소들을 선택할 수 있고, 효율적이고 체계적인 방법이 필요해졌습니다.

## BEM으로 이름 짓기
- BEM : block element modifier의 축약어로 웹사이트에 있는 요소의 일정 부분을 컴포넌트(component:리액트에도 나옵니다)로 나눈 후 그것을 블록으로 지정하는 방식입니다.

card 레이아웃 전체를 하나의 블록으로 보고, 같은 블록이라면 태그명 뒤에 마침표와 해당 블록명을 통일하여 붙여줄겁니다. 블록 안의 요소를 특징적인 이름으로 지은 다음에 언더바 두번(__)입력하고 붙여주는 개발자들의 관행으로 만들었습니다.

05_naming_bem.html 생성하고, 03의 내용을 복사하겠습니다.

BEM을 사용하게 되면 코드량이 줄어들고 요소명이 중복되는 것을 막을 수 있습니다. 근데 길이가 좀 길어지기는 합니다.

경우에 따라서 이상의 세 가지 방법을 잘섞어서 만드는 것이 중요한데, 조직의 성향에 따라서...

ch10_applied_css

# 현대 CSS 요소 지정 방법

# 반복 및 공통되는 스타일
CSS 사용하다보면 여러 페이지에서 같은 코드를 써야할 일이 많습니다.
CSS에서 공통적으로 사용된느 코드를 모듈화하여 다른 CSS 파일로 임포트 하는 방법을 수업할 예정.
자주 사용하는 속성값을 변수로 지정하는 방법 수업 예정.

## 다른 CSS 파일 임포트하기
01_cssimport.html / shared.css / 01_cssimport.css
`@import url(경로)`
그런데 모듈화란 ? : 프로그램을 재사용가능한 단위로 더 작게 나누는 것을 의미함.

## CSS 변수 사용하기
예를 들어 색상을 HEX로 쓰는데 매번 여섯 자리를 입력하려고 하면 기억하기도 얼벼고 실수도 많을 겁니다. 어차피 저희가 기억하는건 5f5f5f 밖에 없으니까요. 이럴 때 원하는 색에 변수명을 할당할 수 있다면 훨씬 편해질 것 같습니다.

CSS에서 변수를 나타낼 때는 원하는 변수명을 지정하고 그 앞에 -- 를 입력해서 변수임을 표시하는 방법이 있습니다.

페이지 메인 컬러라면 --color-main, 가장 작은 텍스트 크기를 지정하고 싶다면 --font-small과 같은 방식이 됩니다. 

ch10의 하위 폴더 cssvariable 폴더를 생성하시오.
01_cssvariable.html / css / common.css 파일을 생성하시오.

```css
u {
  background-color: var(--warn, lightblue);
}
```

```css
.wrong {
  --warn: yellow;
}
```
이상의 두 코드를 고려했을 때 다른 var()와 달리 var(arg1, arg2)형태로 작성되어있습니다. 이는 사용할 수 있으면 --warn 변수를 사용하고, 없을 경우에는 대안(alt)으로 lightblue를 사용하라는 의미로 작성되었습니다.

그리고 전혀 사용하지 않았지만 :root의 경우 최초 디자인 회의시에 작성되는 가장 기초적인 목록 중 하나입니다. 즉 h1에는 --font-xxx-large 변수를 사용한다는 뜻이되겠네요.

색상 조합 참조 사이트 :
https://mycolor.space

03_hover.html

# 웹 폰트 사용하기

## 구글은 webfont.html 확인할 것

## 눈누글꼴
https://noonnu.cc/

```css
@font-face {
    font-family: 'Paperozi';
    src: url('https://cdn.jsdelivr.net/gh/projectnoonnu/2408-3@1.0/Paperlogy-1Thin.woff2') format('woff2');
    font-weight: 100;
    font-display: swap;
}

@font-face {
    font-family: 'Paperozi';
    src: url('https://cdn.jsdelivr.net/gh/projectnoonnu/2408-3@1.0/Paperlogy-2ExtraLight.woff2') format('woff2');
    font-weight: 200;
    font-display: swap;
}

@font-face {
    font-family: 'Paperozi';
    src: url('https://cdn.jsdelivr.net/gh/projectnoonnu/2408-3@1.0/Paperlogy-3Light.woff2') format('woff2');
    font-weight: 300;
    font-display: swap;
}

@font-face {
    font-family: 'Paperozi';
    src: url('https://cdn.jsdelivr.net/gh/projectnoonnu/2408-3@1.0/Paperlogy-4Regular.woff2') format('woff2');
    font-weight: 400;
    font-display: swap;
}

@font-face {
    font-family: 'Paperozi';
    src: url('https://cdn.jsdelivr.net/gh/projectnoonnu/2408-3@1.0/Paperlogy-5Medium.woff2') format('woff2');
    font-weight: 500;
    font-display: swap;
}

@font-face {
    font-family: 'Paperozi';
    src: url('https://cdn.jsdelivr.net/gh/projectnoonnu/2408-3@1.0/Paperlogy-6SemiBold.woff2') format('woff2');
    font-weight: 600;
    font-display: swap;
}

@font-face {
    font-family: 'Paperozi';
    src: url('https://cdn.jsdelivr.net/gh/projectnoonnu/2408-3@1.0/Paperlogy-7Bold.woff2') format('woff2');
    font-weight: 700;
    font-display: swap;
}

@font-face {
    font-family: 'Paperozi';
    src: url('https://cdn.jsdelivr.net/gh/projectnoonnu/2408-3@1.0/Paperlogy-8ExtraBold.woff2') format('woff2');
    font-weight: 800;
    font-display: swap;
}

@font-face {
    font-family: 'Paperozi';
    src: url('https://cdn.jsdelivr.net/gh/projectnoonnu/2408-3@1.0/Paperlogy-9Black.woff2') format('woff2');
    font-weight: 900;
    font-display: swap;
}
```

이상의 코드는 눈누에서 무료 폰트를 가져왔을 때의 부분입니다. @import가 아니죠.
자체 서버에서 서체도 함께 제공하는 것.
`@font-face`에 font-family의 속성값이 다 동일하지만, font-weight에서의 차이가 있음을 확인할 수 있네요.
05_webfont2.html / 05_webfont2.css